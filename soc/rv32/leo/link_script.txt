MEMORY
{
  RAM (rwx) : ORIGIN = 0x10000000, LENGTH = 0x20000
  FLASH (rx) : ORIGIN = 0x8000000, LENGTH = 0x80000
}

SECTIONS
{
	.info :
	{
		KEEP(*(.rodata.__info_array))
		. = ALIGN(0x100);
		. = 0X2000,
	} >FLASH
	__image_lma__ = LOADADDR(.info);

	.text :
    {
		__text_start = .;
        KEEP(*(.text.Reset_Handler))
        KEEP(*(.init))
        KEEP(*(.fini))

        *crtbegin.o(.ctors)
        *crtbegin?.o(.ctors)
        *(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)
        *(SORT(.ctors.*))
        *(.ctors)


        *crtbegin.o(.dtors)
        *crtbegin?.o(.dtors)
        *(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)
        *(SORT(.dtors.*))
        *(.dtors)

        *(.eh_frame*)
        *(.text* .rodata* .srodata*)
		__text_end = .;
    }>FLASH

	.data 0x1000006c :
	{
		. = ALIGN(4);
		__data_start__ = .;
		*(.xip_banned.sleep_recover_asm)
		*(.xip_banned*)
		*(.data* .sdata*)
		__data_end__ = ALIGN(4);
	}>RAM AT>FLASH
	
	__data_lma__ = LOADADDR(.data);

	.bss (NOLOAD):
	{
		__bss_start__ = ALIGN(4);
        *(.sbss*)
        *(.bss*)
        *(COMMON)
        *(SECTION_RTT)
		. = ALIGN(4);
        __bss_end__ = .;
	}>RAM 

    .heap (NOLOAD):
    {
		PROVIDE(end = .);
        KEEP(*(.heap*))
    } > RAM 

	/* .stack_dummy section doesn't contains any symbols. It is only
	 * used for linker to calculate size of stack sections, and assign
	 * values to stack symbols later */
	.stack_dummy (COPY):
	{
		*(.stack*)
	} > RAM

	/* Set stack top to end of RAM, and stack limit move down by
	 * size of stack_dummy section */
	__StackTop = ORIGIN(RAM) + LENGTH(RAM);
	__except_stack_top = __StackTop;
	__StackLimit = __StackTop - SIZEOF(.stack_dummy);
	__start_and_irq_stack_top = __StackLimit;
	PROVIDE(__stack = __StackTop);
	
	/* Check if data + heap + stack exceeds RAM limit */
	/* ASSERT(__StackLimit >= __HeapLimit, "region RAM overflowed with stack") */
	PROVIDE(__global_pointer$ = __data_start__ + (4K / 2) );
	
}